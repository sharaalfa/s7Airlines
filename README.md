#s7hackaton

Extramural stage

Задание первое - Считаем данные по росту и весу (weights_heights.csv, приложенный в задании) в объект DataFrame:
data.py

Задание второе - Постройте 2 раздельные гистограммы распределения роста и веса подростков из выборки data.

Выделите параметры разным цветом и подпишите оси.

Cоздаем класс с методами в function.py, в том числе для создания раздельных гистограмм:

createHist(self, v, n, v1, v2, v3, w, m, w1, w2, w3) с необходимыми параметрами, и вызываем его в commonHistogram.py,

в котором получаем данные из data.py

Задание третье - Добавьте третий признак ('BMI').

Создайте признак Индекс массы тела (BMI).

Для этого воспользуйтесь коэффициентами перевода единиц с точностью до 5 знака после запятой.

index.py

Создаем временный файл temporary.py при помощи createTemporaryFile() класса Determinator() уже! 

в funtion2.py (для исключения коллизий в использовании памяти).

Пробегаемся по 25000 наблюдениям и рассчитываем BMI, затем записываем в созданный временный файл с помощью
writeToFile того же класса. Далее как в data.py

Задание четвертое -  Постройте картинку, на которой будут отображены попарные зависимости

признаков , 'Height', 'Weight' и 'BMI' друг от друга.
 pairRelation.py
 
 Создаем метод createPair(self, a, b, c),  в котором строются попарные кривые
 
 трех величин с помощью функции setValues(self, x), возращающий x.
 
Оба в классе Determinator() function.py 

Задание пятое - Создайте в DataFrame data новый признак weight_category,

который будет иметь 3 значения: 1 – если вес меньше 120 фунтов. (~ 54 кг.),
3 - если вес больше или равен 150 фунтов (~68 кг.), 2 – в остальных случаях.
Постройте boxplot, демонстрирующий зависимость роста от весовой категории.
Подпишите ось y меткой «Рост», ось x – меткой «Весовая категория».
category.py
boxplot.py
Создаем вызываемый метод weight_category(self) в классе Determinator() function.py.
Затем аналогично как в data.py создаем датафрейм и рисуем боксплот.
Задание шестое -
Постройте scatter plot зависимости роста от веса.
Подпишите картинку.
satter.py
Создаем метод getScatter(self) в классе Calculator() function.py

и вызываем его в scatter.py

Задание седьмое - Написать функцию, которая по двум параметрам 

w0 и w1 вычисляет квадратичную ошибку приближения зависимости

роста y от веса x прямой линией y = w0 + w1*x:

error=sum_i (y_i - (w0 + w1*x_i))^2 n-наблюдений

метод getSquareError(self,w0, w1) в классе Calculator() function.py

Задание восьмое - провести две прямые на графике созданного скаттер

роста и веса (w0, w1) = (55, 0.04), (w0,w1) = (50, 0.22).

Создается метод getChart(self, w0, w1) в Calculator(), в котором

вызывается известный уже метод getScatter(self),

который сам исполняется в chart.py.

Задание девятое - построить график при w0=50.

Создается метод getChart2(self), который вызывается в chart2.py

Задание десятое - найти минимум вышеуказанной функции ошибки

w1 на отрезке [-5, 5]. Создать график на полученном скаттере

прямой при (w0, w1) = (50, w0opt), где w0opt - полученный минимум w1.

Создаем метод getMin(self), в котором создается временный файл, рассчитывается error

 и выбирается минимум функции, тобишь w1. Затем строится график 
 
 с помощью ф-ции getChart(self, w0, w1) при исполнении chart3.py.
 
 Задание одиннацатое - построить 3D график функции ошибки.
 
 3Dchart.py
 
 Задание двенадцатое - найти минимум функции двух переменных
 
 с использованием метода оптимизации алгоритмом Бройдена-Флетчера-Гольдфарба-Шанно.
 
 Постройте график на скаттере роста и веса полученной прямой.
 
 Создаем метод getMinOfLBFGS(self), который рассчитываем миннимум функции
  
  двух переменных w0 и w1 при помощи метода funcXX(self, x).
  
  Исполняется метод в chart4.py,  где строится вместе сс скаттером.